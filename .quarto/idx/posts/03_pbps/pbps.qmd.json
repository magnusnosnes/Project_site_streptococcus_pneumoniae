{"title":"Penicillin binding proteins","markdown":{"yaml":{"title":"Penicillin binding proteins","date":"2022-12-14","editor":"visual","image":"cover2.png","bibliography":"../disentangling.bib","knitr":{"opts_chunk":{"comment":"#>","warning":false,"message":false,"collapse":true,"cache":false}},"execute":{"echo":false,"message":false},"format":{"html":{"fig-width":12,"fig-height":16,"page-layout":"full","toc":true,"toc-location":"left"}}},"headingText":"Outline","containsRefs":true,"markdown":"\n\n\nPBPs are proteins that can attach to $\\beta$-lactam antibiotics like penicillin. These proteins are essential for making the bacterial cell wall, and when they are bound by penicillin, the antibiotic can disrupt this process. As a result, the growth and division of the bacterial cells can be impaired, making the antibiotic effective at killing or inhibiting the growth of the bacteria.\n\nThe PBP types shown in this document were obtained by using Pathogenwatch, which applies a PBP typing scheme developed in [@li2016] and evaluated in [@li2017]. These studies demonstrated that the PBP types account for most of the variation in observed minimum inhibitory concentration $\\beta$-lactam antibiotic, and perform better than other typing schemes such as MLST.\n\nTo identify small and novel mechanisms that contribute to penicillin resistance, it can be helpful to control for major effects. Therefore, it is important to consider PBP composition.\n\nThis document gives an overview of the PBP types present in collection which will control for in further analyses. The visualization can be used to explore the PBP types, how they are associated with MIC values, and how they are distributed through time in the different studies included in the collection. It is noteworthy that multiple PBP alleles are labelled as \"new\" in each of the genes PBP1a, PBP2b and PBP2x, and therefore that the effect of this allele composition has not been previously investigated.\n\n```{r }\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(shiny)\nlibrary(highcharter)\nlibrary(tidyverse)\nlibrary(lubridate)\n# Specify the names of the files to read\nfilenames <- c(\"pbps_USA.csv\", \"pbps_maela.csv\", \"pbps_massachusetts.csv\", \n               \"pbps_norway_historic.csv\", \"pbps_norway_routine.csv\", \"pbps_south_africa.csv\")\nfilenames = paste0(\"/Users/magnusnygardosnes/Desktop/Postdoc/Pneumo/03_PBPs/\", filenames)\n\n# Read each file and store the resulting data frame in a list\ndata_frames <- lapply(filenames, read.csv)\n\nn_in_study = unlist(lapply(data_frames, nrow))\ndataset = rep(c(\"USA\", \"maela\", \"massachusetts\", \"norway_historic\", \"norway_routine\", \"south_africa\"), n_in_study)\n# Use rbind to combine the data frames in the list into a single data frame\ncombined_data <- do.call(rbind, data_frames)\ncombined_data$dataset = dataset\n\nwrite.table(combined_data,\"~/Dropbox/Postdoc_pneumococcus/00_Collection_overview/PBPs.csv\")\nmetadata_including_dates = read.table(\"~/Dropbox/Postdoc_pneumococcus/00_Collection_overview/total_metadata_processed_and_combined.csv\")\n\n# Remove .fasta from the genome names\nmetadata_including_dates$fasta_name = str_replace_all(metadata_including_dates$fasta_name,\".fasta\", \"\")\n\nMIC_dat = read.csv(\"/Users/magnusnygardosnes/Desktop/Postdoc/Pneumo/06_Pyseer/phenotype.tsv\", sep=\"\\t\")\ncombined_data$dates = metadata_including_dates$Date[match(combined_data$Genome.Name,metadata_including_dates$fasta_name)]\ncombined_data$penMIC_observed = MIC_dat$penicillin_G[match(combined_data$Genome.Name, MIC_dat$samples)]\ncombined_data$PBP_type = paste0(combined_data$PBP1a,\"-\",combined_data$PBP2b,\"-\",combined_data$PBP2x)\ncombined_data = combined_data %>% group_by(PBP_type) %>% mutate(PBP_type_median_MIC=median(penMIC_observed, na.rm=T))\ncombined_data = combined_data %>% group_by(PBP_type) %>% mutate(PBP_type_mean_MIC=mean(penMIC_observed, na.rm=T))\ncombined_data = combined_data %>% group_by(PBP_type) %>% mutate(PBP_type_ranked_MIC=rank(PBP_type_mean_MIC))\ncombined_data=as.data.frame(combined_data)\n\n# Look at PBP type MIC distribution\n# table(combined_data$PBP_type,combined_data$penMIC_observed,useNA = \"always\")\n# table(combined_data$PBP_type,combined_data$penMIC_observed,useNA = \"always\")\n# table(combined_data %>% filter(dataset==\"norway_routine\") %>% select(dates,penMIC_observed),useNA=\"always\")\n\n\n\n\n\n#Check if we have dates now\n#tail(table(combined_data$dates,combined_data$dataset),100)\n\n\n#Set up a palette for the MIC values\n# library(RColorBrewer)\n# n_unique_mic = length(sort(unique(combined_data$PBP_type_mean_MIC)))\n# color_scale <- colorRampPalette(c(\"blue\", \"red\"))\n# colors <- color_scale(n_unique_mic)\n# colors = c(colors, \"NA\"=\"#000000\")\n# names(colors)=unique(sort(unique(combined_data$PBP_type_mean_MIC)))\n# match_vector = match(combined_data$PBP_type_mean_MIC, names(colors))\n# match_vector[is.na(match_vector)] = 32\n# combined_data$mic_colors = colors[match_vector]\n# combined_data %>% select(tail(names(combined_data),5))\n\n# Data formatting done.\n\n#Testing a reduced dataset for simpler plotting\nreduced_data = combined_data %>% select(c(dataset,PBP_type,penMIC_observed,PBP_type_median_MIC,PBP_type_mean_MIC))\n\n#Calculate the rank of the PBP types:\nreduced_data %>% \n  group_by(PBP_type) %>% \n  summarize(median = median(PBP_type_median_MIC)) %>% \n  arrange(median) %>% \n  mutate(rank = row_number()) -> ranked_dataset\n\n# ranktable = rank(sort(unique(reduced_data$PBP_type_median_MIC)))\n# names(ranktable) = sort(unique(reduced_data$PBP_type_median_MIC))\n# ranktable=c(ranktable, \"NA\"=\"67\")\n# reduced_data$y_pos = as.numeric(as.character(ranktable[match(reduced_data$PBP_type_median_MIC, names(ranktable))]))\nt1 = table(combined_data$PBP_type)\nindmatch = match(ranked_dataset$PBP_type, names(t1))\nranked_dataset$counts = as.numeric(as.character(t1[indmatch]))\nranked_dataset$width=sqrt(ranked_dataset$counts)\n#Remove all but one row for each PBP_type\n\n#We need ymin and ymax for the rectangles. \n\nymin=rep(0, nrow(ranked_dataset))\nymax=rep(0, nrow(ranked_dataset))\n\n#Calculate y-positions of rectangles\nfor(i in 1:nrow(ranked_dataset)) {\n  \n  if(i!=1){\n    ymin[i] = ymax[i-1]+0.1  \n  }\n  \n  \n  width = ranked_dataset$width[i]\n  #Set minimum width\n  if(width<=0.1){\n    width = 0.1\n  }\n  ymax[i]=ymin[i]+width\n}\nranked_dataset$ymin = ymin\nranked_dataset$ymax = ymax\nranked_dataset$ymed = (ymax+ymin)/2\n\n\n# Functions needed for this post.\n\nreorder_and_sort_factor = function(data,column) {\n  \n  #Count and reorder by counts\n  pbp_tab = table(data[,column])\n  pbp_tab = sort(pbp_tab, decreasing=T)\n  #Store the non_numeric values\n  extra = pbp_tab[names(pbp_tab)%in%c(\"NF\", \"NEW\")]\n  #Remove the non-numeric values\n  pbp_tab = pbp_tab[(names(pbp_tab)%in%c(\"NF\", \"NEW\"))==F]\n  pbp_tab = c(pbp_tab,extra)\n  pbp_tab  = as.data.frame(pbp_tab)\n  pbp_tab$type=rownames(pbp_tab)\n  pbp_tab$type = factor(pbp_tab$type, levels=pbp_tab$type)\n  pbp_tab$counts = pbp_tab$.\n  rownames(pbp_tab)=NULL\n  pbp_tab\n}\n\n\nbarplot_pbps_in_dataset <- function(data, dataset,plot=F){\n  #Debug:\n  #data = combined_data; dataset=\"USA\";\n  \n  # Select rows that correspond to the given country\n  selected_data <- data[data$dataset == dataset,]\n  \n  #Count and reorder by counts\n  pbp1a_tab = reorder_and_sort_factor(selected_data,\"PBP1a\")\n  pbp2b_tab = reorder_and_sort_factor(selected_data,\"PBP2b\")\n  pbp2x_tab = reorder_and_sort_factor(selected_data,\"PBP2x\")\n  \n  # Create barplots for PBP1a, PBP2b, and PBP2x\n  pbp1a <- ggplot(pbp1a_tab, aes(x=type,y=pbp_tab)) +\n    geom_bar(stat = \"identity\")+theme_bw()+xlab(\"PBP1a type\")+theme(axis.text.x = element_text(angle = 90))+ylab(\"PBP1a\")\n  \n  pbp2b <- ggplot(pbp2b_tab, aes(x=type,y=pbp_tab)) +\n    geom_bar(stat = \"identity\") +theme_bw()+xlab(\"PBP1a type\")+theme(axis.text.x = element_text(angle = 90))+ylab(\"PBP2b\")\n  \n  pbp2x <- ggplot(pbp2x_tab, aes(x=type,y=pbp_tab)) +\n    geom_bar(stat = \"identity\") +theme_bw()+xlab(\"PBP1a type\")+theme(axis.text.x = element_text(angle = 90))+ylab(\"PBP2x\")\n  \n  # Arrange plots in 3 rows and 1 column\n  if(plot==T){\n    grid.arrange(pbp1a, pbp2b, pbp2x, nrow = 3)  \n  }\n  return(list(\"pbp1a\"=pbp1a,\"pbp2b\"=pbp2b,\"pbp2x\"=pbp2x))\n}\n\n\ninteractive_pbps = function(output_barplots) {\n  #plotly::ggplotly(output_barplots$pbp1a)\n  #output_barplots = barplot_pbps_in_dataset(combined_data,\"norway_routine\")\n  plots = subplot(output_barplots$pbp1a, output_barplots$pbp2b, output_barplots$pbp2x, nrows = 3, titleY = TRUE)\n  ggplotly(plots,layout(autosize = F, width = 500, height = 500))\n}\n\n\nmake_plots = function(total_data, dataset) {\n  c1 = barplot_pbps_in_dataset(total_data,dataset)\n  interactive_pbps(c1)\n}\n\n\nplot_fraction_by_year_and_dataset=function(dataset=\"norway_historic\") {\n  data = combined_data[combined_data$dataset %in% dataset,]\n  data = data %>% select(tail(names(data),7))\n  #Remove NA\n  #data = data[-which(is.na(data$PBP_type_median_MIC)),]\n  \n  #Sort the data in descending order, then reverse the stack to put NA's on top. \n  data = data %>% arrange(desc(PBP_type_median_MIC))\n  data[order(data$PBP_type_median_MIC, na.last = TRUE), ]\n  data$PBP_type <- factor(data$PBP_type, levels = unique(data$PBP_type))\n  \n  g1 = ggplot(data)+\n  geom_bar(aes(x=floor(dates), group=PBP_type, fill=PBP_type_median_MIC, text = paste(\"Count: \", ..count..)),position = position_stack(reverse = TRUE))+\n  theme_classic()+\n  scale_fill_gradient2(low = \"lightblue\", mid = \"red\", high = \"darkred\", midpoint = 8)+\n    scale_x_continuous(labels = as.character(seq(min(floor(data$dates),na.rm=T), max(floor(data$dates),na.rm=T), by = ifelse(length(unique(floor(data$dates))) > 10, 5, 1))), breaks = seq(min(floor(data$dates),na.rm=T), max(floor(data$dates),na.rm=T), by = ifelse(length(unique(floor(data$dates))) > 10, 5, 1)))+\n     labs(y = \"Number of isolates\",\n       fill=\"Median MIC of PBP-type\",\n       x=\"Year\")\n  ggplotly(g1)\n}\n\n\n\nplot_fraction_by_year_and_dataset2 = function(dataset=\"norway_historic\") {\n  data = combined_data[combined_data$dataset %in% dataset,]\n  data = data %>% select(tail(names(data),7))\n  data = data %>% arrange(desc(PBP_type_median_MIC))\n  data$PBP_type <- factor(data$PBP_type, levels = unique(data$PBP_type))\n  \n  g1 = ggplot(data)+\n  geom_bar(aes(x=floor(dates), y = ..prop.., group=PBP_type, fill=PBP_type_median_MIC, text = paste(\"Count: \", ..count..)), position=position_fill(reverse = TRUE))+\n  theme_classic()+\n  scale_fill_gradient2(low = \"lightblue\", mid = \"red\", high = \"darkred\", midpoint = 8)+\n    scale_x_continuous(labels = as.character(seq(min(floor(data$dates),na.rm=T), max(floor(data$dates),na.rm=T), by = ifelse(length(unique(floor(data$dates))) > 10, 5, 1))), breaks = seq(min(floor(data$dates),na.rm=T), max(floor(data$dates),na.rm=T), by = ifelse(length(unique(floor(data$dates))) > 10, 5, 1)))+\n     labs(y = \"Proportion of isolates\",\n       fill=\"Median MIC of PBP-type\",\n       x=\"Year\")\n  ggplotly(g1)\n}\n\nplot_fraction_by_year_and_dataset3 = function(dataset=\"norway_historic\") {\n  data = combined_data[combined_data$dataset %in% dataset,]\n  data = data %>% select(tail(names(data),7))\n  data = data %>% arrange(desc(PBP_type_median_MIC))\n  data$PBP_type <- factor(data$PBP_type, levels = unique(data$PBP_type))\n  #Remove NA\n  if(length(which(is.na(data$PBP_type_median_MIC)))>=1) {\n    data = data[-which(is.na(data$PBP_type_median_MIC)),]\n  }\n  \n  \n  xlabs = as.character(seq(min(floor(data$dates),na.rm=T), max(floor(data$dates),na.rm=T), by = ifelse(length(unique(floor(data$dates))) > 10, 5, 1)))\n  g1 = ggplot(data)+\n  geom_bar(aes(x=floor(dates), y = ..prop.., group=PBP_type, fill=PBP_type_median_MIC, text = paste(\"Count: \", ..count..)), position=position_fill(reverse = TRUE))+\n  theme_classic()+\n  scale_fill_gradient2(low = \"lightblue\", mid = \"red\", high = \"darkred\", midpoint = 8)+\n    scale_x_continuous(labels = xlabs,\n                       breaks = as.numeric(xlabs))+\n     labs(y = \"Proportion of isolates\",\n       fill=\"Median MIC of PBP-type\",\n       x=\"Year\")\n  ggplotly(g1)\n}\n\n```\n\n````{=html}\n<!-- ::: {.panel-tabset style=\"width:135%\"}\n## Norway Routine\n\n```{r}\nmake_plots(combined_data,\"norway_routine\")\n```\n\n## Norway historic\n\n```{r}\nmake_plots(combined_data,\"norway_historic\")\n```\n\n## Maela\n\n```{r}\nmake_plots(combined_data,\"maela\")\n```\n\n## South Africa\n\n```{r}\nmake_plots(combined_data,\"south_africa\")\n```\n\n## Massachusetts\n\n```{r}\nmake_plots(combined_data,\"massachusetts\")\n```\n\n## USA\n\n```{r}\nmake_plots(combined_data,\"USA\")\n```\n::: -->\n````\n\n# Abundance and median observed MIC of PBP types\n\n::: {.panel-tabset style=\"width:135%\"}\n# PBP types and observed MIC\n\n```{r}\n\nranked_dataset_large_width = ranked_dataset %>%\n  filter(width > 5)\n\ng1 = ggplot(ranked_dataset) +\n  geom_rect(aes(xmin = 0, xmax = 1, ymin = ymin, ymax = ymax, fill=median, text=paste(\"PBP type: \",PBP_type,\"<br>\",\"Number of genomes: \",counts))) +\n  geom_text(data = ranked_dataset_large_width, aes(y = ymed, x=-0.005, label = PBP_type), size = 2.5, hjust = 0) +\n  labs(x = NULL, y = \"PBP-type\") +\n  theme_classic() +\n  scale_fill_gradient2(low = \"lightblue\", mid = \"red\", high = \"darkred\", midpoint = 8)+labs(fill=\"Median MIC of PBP-type\")\nggplotly(g1)\n```\n:::\n\n## Temporal PBP composition\n\n::: {.panel-tabset style=\"width:135%\"}\n## Norway historic\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"norway_historic\")\n```\n\n## Norway routine\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"norway_routine\")\n```\n\n## Maela\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"maela\")\n```\n\n## South Africa\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"south_africa\")\n```\n\n## Massachusetts\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"massachusetts\")\n```\n\n## The USA\n\n```{r}\nplot_fraction_by_year_and_dataset(dataset=\"USA\")\n```\n:::\n\n## Temporal PBP composition (fraction of total)\n\n::: {.panel-tabset style=\"width:135%\"}\n## Norway historic\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"norway_historic\")\n```\n\n## Norway routine\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"norway_routine\")\n```\n\n## Maela\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"maela\")\n```\n\n## South Africa\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"south_africa\")\n```\n\n## Massachusetts\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"massachusetts\")\n```\n\n## The USA\n\n```{r}\nplot_fraction_by_year_and_dataset2(dataset=\"USA\")\n```\n:::\n\n## Temporal PBP composition (fraction of total removing NA's)\n\n::: {.panel-tabset style=\"width:135%\"}\n## Norway historic\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"norway_historic\")\n```\n\n## Norway routine\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"norway_routine\")\n```\n\n## Maela\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"maela\")\n```\n\n## South Africa\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"south_africa\")\n```\n\n## Massachusetts\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"massachusetts\")\n```\n\n## The USA\n\n```{r}\nplot_fraction_by_year_and_dataset3(dataset=\"USA\")\n```\n:::\n\n# References\n\n::: {#refs}\n:::\n\n```{r, include=F, eval=F}\nThis is my data:\n\n> df_norway2\n# A tibble: 816 × 5\n# Groups:   dates [33]\n   dates PBP_type      n PBP_type_median_MIC percentage\n   <dbl> <fct>     <int>               <dbl>      <dbl>\n 1  1998 2-0-61        1              0.004    0.0294  \n 2    NA NEW-0-6       1              0.008    0.000767\n 3  2000 23-4-468      1              0.012    0.0333  \n 4  1985 86-82-162     2              0.015    0.0556  \n 5  1988 0-0-6         1              0.015    0.0303  \n 6    NA 3-NEW-5       2              0.015    0.00153 \n 7    NA 3-6-NEW       2              0.0155   0.00153 \n 8  1982 3-6-5         1              0.016    0.0345  \n 9  1982 62-0-2        3              0.016    0.103   \n10  1983 62-0-2        4              0.016    0.125   \n# … with 806 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\nI want to use plotly in R.\nI want to plot stacked areas graph of the percentage column.\nI want the areas grouped grouped and ordered by PBP_type, with lines separating each area.\nI want the fill to be colored according to the value of PBP_type_median_MIC with a color scale c(\"lightblue\", \"red\", \"darkred\")) corresponding to continous values from 0-16. \nCan you help me write the code my code to achieve this?  \n\n\n  \n  \n  # Create a color scale based on PBP_type_median_MIC\ncolor_scale <- list(\n  c(0, \"lightblue\"),\n  c(16/100, \"red\"),\n  c(1, \"darkred\")\n)\n\n# Plot stacked areas graph of percentage column\nplot_ly(df_norway2,\n        x = ~dates,\n        y = ~percentage,\n        color = ~PBP_type_median_MIC,\n        colors = color_scale,\n        type = \"scatter\",\n        mode = \"none\",\n        fill = \"tonexty\",\n        hoverinfo = \"text\",\n        text = ~paste(\"PBP type:\", PBP_type)\n) %>%\n  layout(\n    title = \"Stacked areas graph of percentage column by PBP type\",\n    xaxis = list(title = \"Dates\"),\n    yaxis = list(title = \"Percentage\")\n  )\n  \n  # filter out rows with missing dates\ndf_norway3 <- df_norway2\n\n# create a custom colorscale\ncscale <- colorRamp(c(\"lightblue\", \"red\", \"darkred\"))\n\n# plot a stacked area graph\np <- df_norway3 %>%\n  group_by(PBP_type) %>%\n  plot_ly(x = ~dates,\n          y = ~percentage,\n          type = \"scatter\",\n          mode = \"none\",\n          color = ~PBP_type_median_MIC,\n          colors = cscale,\n          fill = \"tonexty\") %>%  add_trace() %>%  \n  layout(title = \"Stacked Area Graph of Percentage by PBP_type\",\n         xaxis = list(title = \"Dates\"),\n         yaxis = list(title = \"Percentage\"),\n         coloraxis = list(colorbar = list(title=\"PBP_type_median_MIC\")))\n\np\n#   ____________________________________________________________________________\n#   prompt                                                                  ####\n# My dataset looks like this:\n# \n#   PBP1a PBP2b PBP2x dataset\n# 1    42    42     8     USA\n# 2     1     0     6     USA\n# 3     2     4     0     USA\n# \n# I want to make a function that plots barplots of the PBP1a, PBP2b, and the PBP2x columns in the combined dataset. \n# Use ggplot to do following things: \n# Define a barplot function called barplot_pbps_in_dataset.\n# Make the barplot function select the rows of the combined data that corresponding to an user input value (string).\n# Make a barplot of PBP1a using ggplot on the the selected rows. Set the title of the plot to PBP1a.\n# Make a barplot of PBP2b using the selected rows. Set the title of the plot to PBP2b.\n# Make a barplot of PBP2x using the selected rows. Set the title of the plot to PBP2x.\n# Arrange the barplots in 3 rows and 1 column, and return the plot to the user.\n# \n#  [1] \"42\"  \"1\"   \"2\"   \"45\"  \"0\"   \"NF\" \"NEW\" \"208\" \"141\" \"111\"\n# R-programming language. \n# Reorder this factor variable by dplyr and sort by the sorting by numeric values. Make any non-numeric values appear last. turn it back into a factor\n# \n\n#   PBP-MIC_plot                                                            ####\n# library(ggplot2)\n# \n# \n# library(plotly)\n# ggplot(reduced_data, aes(x=PBP_type,y=y_pos, color=PBP_type_median_MIC))+\n#   geom_point()+\n#   scale_color_gradient(low=\"blue\",\n#                      high=\"red\", space =\"Lab\" )\n\n\n# g1 =ggplot(ranked_dataset) +\n#     geom_rect(aes(xmin = 0, xmax = 1, ymin = ymin, ymax = ymax, fill=median)) +\n#     labs(x = NULL, y = \"PBP-type\")+theme_light()+scale_fill_gradient2(low = \"lightblue\",mid=\"red\",high = \"darkred\", midpoint=8)\n# ggplotly(g1)\n# \n# \n# ranked_dataset_large_width = ranked_dataset %>%\n#   filter(width > 5)\n# \n# g1 = ggplot(ranked_dataset) +\n#   geom_rect(aes(xmin = 0, xmax = 1, ymin = ymin, ymax = ymax, fill=median, text=paste(\"PBP type: \",PBP_type,\"<br>\",\"Number of genomes: \",counts))) +\n#   geom_text(data = ranked_dataset_large_width, aes(y = ymed, x=-0.005, label = PBP_type), size = 2.5, hjust = 0) +\n#   labs(x = NULL, y = \"PBP-type\") +\n#   theme_light() +\n#   scale_fill_gradient2(low = \"lightblue\", mid = \"red\", high = \"darkred\", midpoint = 8)\n# g1\n# ggplotly(g1)\n\n# ggplot(reduced_data, aes(x = PBP_type, y = PBP_type_median_MIC, color = mic_colors, size = PBP_type_ranked_MIC)) + \n#   geom_point() + \n#   scale_color_identity() +\n#   ggtitle(\"Scatter Plot of penMIC_observed and PBP_type_median_MIC\") +\n#   xlab(\"penMIC_observed\") +\n#   ylab(\"PBP_type_mean_MIC\")+theme_light()+xlab(\"\")\n# ggplotly()\n\n```\n"},"formats":{"html":{"execute":{"fig-width":12,"fig-height":16,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"pbps.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"lux","title":"Penicillin binding proteins","date":"2022-12-14","image":"cover2.png","bibliography":["../disentangling.bib"],"knitr":{"opts_chunk":{"comment":"#>","warning":false,"message":false,"collapse":true,"cache":false}},"page-layout":"full","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}}}